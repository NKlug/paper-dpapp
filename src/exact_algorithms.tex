	Zu Beginn betrachten wir zwei einfache exakte Algorithmen.
    Seien wieder $d\geq1$, $t>1$ und $P = (p_1, p_2, \mathellipsis, p_n)$ ein Kantenzug in $\R^d$. Sei weiter $P^*$ die Menge aller minimalen $t$-distanzerhaltenden Approximationen
    
    Wir konstruieren jetzt den gerichteten Graphen $G_t = (V,E_t)$, wobei V genau aus den Knoten des Pfades $P$ besteht und 
    $E_t = \{(p_i, p_j) \in V\times V|\ i < j \text{ und } (p_i,p_j)\ \text{ist $t$-distanzerhaltend}\}$. $E_t$ ist also gerade die Menge aller $t$-distanzerhaltenden Kanten zwischen Knoten aus $V$. Zunächst beobachten wir, dass jede $t$-distanzerhaltende Approximation von $P$ einem Pfad in $G_t$ entspricht, da $G_t$ alle $t$-distanzerhaltenden Kanten zwischen Knoten von $P$ enthält. Andererseits ist auch jeder Pfad $Q = (p_{i_1}, p_{i_2}, \mathellipsis, p_{i_k})$ mit $1 = i_1 < i_2 < \mathellipsis < i_k = n$ in $G_t$ eine $t$-distanzerhaltende Approximation von $P$, da nur $t$-distanzerhaltende Kanten verwendet werden. Daraus folgt, dass auch ganz $P^*$ in $G_t$ liegt. Jetzt müssen wir also nur noch ein Element aus $P^*$ ermitteln. Das ist leicht: Wir führen eine Breitensuche in $G_t$ mit Startknoten $p_1$ durch, bei der wir jeden Knoten mit der Nummer des Knotens beschriften, von dem aus er zum ersten Mal entdeckt wurde (also mit der Nummer seines Vaters im BFS-Baum). Am Ende lesen wir diese Beschriftung bei $p_n$ beginnend solange aus, bis wir $p_1$ erreichen. Der dadurch entstandene Pfad entspricht dann aufgrund der Eigenschaften der Breitensuche einem Kantenzug aus $P^*$. 
    Nun betrachten wir noch die Laufzeit: Die Konstruktion von $G_t$ gelingt uns in $O(n^2)$, da wir für maximal $\binom{n}{2} = O(n^2)$ Kanten überprüfen müssen, ob diese $t$-distanzerhaltend sind. Sei $m$ die Zahl der Kanten in $G_t$, dann wissen wir aus  \cite{hagerup}, dass die Breitensuche $O(n+m)$ Zeit dauert. In unserem Fall (und auch sonst immer) ist $m = O(n^2)$, und somit kostet die Breitensuche $O(n^2)$ Zeit. Insbesondere haben wir:
    \begin{theorem}
    	\label{theo:mvpsex}
    	Das Minimum-Vertex-Path-Simplification Problem kann für Pfade mit n Knoten $O(n^2)$ gelöst werden.
    \end{theorem} 
    
    Als nächstes wollen wir uns überlegen, wie man das MDPS-Problem für eine feste Anzahl von Knoten $k$ lösen kann. Sei im Folgenden $\kappa_t$ die geringst mögliche Zahl von Knoten für eine $t$-distanzerhaltende Approximation von $P$.
	\begin{lemma}
		\label{lem:kappa}
		Sind $t, t' \in \R$ und $1 \leq t < t'$, dann ist $\kappa_t \geq \kappa_{t'}$.
	\end{lemma}
	\begin{proof}
		Wäre $\kappa_{t'} < \kappa_t$, hätte eine minimale $t'$-distanzerhaltende Approximation echt weniger Knoten als eine minimale $t$-distanzerhaltende. Aber jede $t$-distanzerhaltende Approximation von $P$ ist nach Korollar \ref{cor:approximations} auch eine $t'$-distanzerhaltende Approximation. Das ist ein Widerspruch. 
	\end{proof}
	
	Da $G_t$ maximal $O(n^2)$ Kanten enthält, gibt es eine endliche Zahl von $t$-Werten. 
	Wir müssen also nur noch aus diesen Werten den geringsten Wert $t^*$ ermitteln, für den eine $t^*$-distanzerhaltende Approximation existiert, die gerade noch k Knoten oder weniger hat. 
	Dazu definieren wir zunächst $t^*_{ij} \coloneqq\frac{\delta(p_i, p_j)}{|p_i p_j|}$ für $1\leq i < j \leq n$ als die Abweichung der Kante $(p_i, p_j)$ vom Pfad. Sei nun $M\coloneqq\{t^*_{ij}\ |\ 1\leq i < j \leq n\}$. 
	Wir wissen, dass $t^* \in M$, da die gesuchte Approximation eine Kante mit maximalen $t$-Wert hat, und $M$ gerade alle diese enthält. 
	Aus Lemma \ref{lem:kappa} wissen wir außerdem, das sich die $\kappa_t$ umgekehrt proportional zu den $t$-Werten verhalten. 
	Sortieren wir jetzt $M$ zu $M'$, können wir in $M'$ nach $t^*$ suchen. Da $M$ $O(n^2)$ Elemente enthält, können wir $M$ bekanntermaßen (siehe \cite{hagerup}) in $O(n^2\log n^2)=O(n^2\log n)$ sortieren. 
	Für die Suche verwenden wir eine Binärsuche, bei der wir jeweils für den aktuell betrachteten $t$-Wert das MVPS-Problem lösen und dann abhängig vom Ergebnis entweder im rechten oder linken Teilbereich weitersuchen. 
	Eine gewöhnliche Binärsuche kostet $O(\log n)$ Zeit und mit Satz \ref{theo:mvpsex} ergibt sich auch hierfür eine Laufzeit von $O(n^2\log n)$. Wir halten fest:
	\begin{theorem}
		Das Minimum Dilation Path Simplification Problem kann für Pfade mit n Knoten in $O(n^2 \log n)$ gelöst werden.
	\end{theorem}
	
	Damit beschließen wir das Kapitel über exakte Algorithmen für das MVPS- und das MDPS-Problem und wenden uns approximativen Lösungen zu.
