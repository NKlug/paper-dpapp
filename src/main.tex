%%
%% Author: nikolas
%% 11.03.18
%%

% Preamble
\documentclass[11pt]{article}

% Packages
%\usepackage{a4wide}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage[german]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage[plain]{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage[font=small]{caption}
%\usepackage{hyperref} % Makes citations clickable


\newcommand{\R}{\mathbb{R}}
\newcommand{\n}{\newline}
\renewcommand{\refname}{Referenzen}
\renewcommand{\baselinestretch}{1.15} % line distance
\renewcommand{\proofname}{\Beweis} % name proofs 'Beweis'
\addto\captionsgerman{\renewcommand{\figurename}{Abb.}} % name figures 'Abb.' (change it for babel)

\setitemize{itemsep=0mm} % itemize line distance
\setenumerate{label=(\arabic*),itemsep=0mm} % enumerate labeling and line distance
\allowdisplaybreaks % make math equations breakable

\newtheorem{theorem}{Satz}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{corollary}[theorem]{Korollar}

% Headline
\title{Distanzerhaltende Approximation von Kantenzügen}
\author{Nikolas Klug}
\date{Sommersemester 2018
	\\ Universität Augsburg
	\\ Seminar Algorithmen und Datenstrukturen}


% Document
\begin{document}
    \maketitle

    \begin{abstract}
        Diese Seminararbeit basiert auf \glqq Distance-preserving approximations of polygonal paths\grqq\ von J. Gudmundsson et al. (\cite{gudmundsson}). Sei $P = (p_1, p_2, \mathellipsis p_n)$ ein Kantenzug und $t \geq 1$. Ein Kantenzug $Q$ approximiert $P$, falls er nur aus Punkten von $P$ besteht und falls dessen Kanten jeweils nur um $t$ vom $P$ abweichen. Diese Arbeit stellt exakte und approximative Algorithmen dar, um $Q$ so zu berechnen, dass $Q$ entweder die minimale Zahl von Knoten besitzt, oder für eine feste Knotenzahl 
        minimales $t$ hat.
    \end{abstract}

    \section{Einführung und Definitionen}
    \label{sec:intro}

	Ein \emph{(polygonaler) Kantenzug} $P = (p_1, p_2, \mathellipsis, p_n)$ ist eine Aneinanderreihung von Geradensegmenten, die für $1 \leq i < n$ jeweils $p_i$ und $p_{i+1}$ verbinden. Bei den $p_i$ handelt es sich dabei um Punkte aus dem $\R^d$ (für $d \in \mathbb{N}$). Aufgrund der starken Ähnlichkeit zu gerichteten Pfaden in Graphen, werden wir für Kantenzüge auch häufig Begriffe aus der Graphentheorie verwenden. Beispielsweise heißen die Punkte des Kantenzuges  auch Knoten, die verbindenden Geraden auch (gerichtete) Kanten etc.

    Sei $d\geq1$ und $(p_1, p_2, \mathellipsis, p_n)$ ein Kantenzug $P$, dessen Knoten alle in $\R^{d}$ liegen.
    Ein solcher Kantenzug kann mitunter eine hohe Zahl von Knoten besitzen, die sehr dicht beieinander liegen und leicht durch deutlich weniger Kanten approximiert werden können, wobei sich wichtige Parameter nicht stark ändern. In der Fachliteratur werden dabei zahlreiche Kriterien aufgeführt, einige davon sind die Fläche, die der Pfad einschließt und die Distanz bzw. die Länge des Pfades. In dieser Arbeit soll es um Algorithmen gehen, die einen solchen Pfad unter ungefährer Einhaltung der Länge approximieren. Dabei betrachten wir zunächst zwei exakte Algorithmen und später noch zwei approximative, die eine deutliche bessere Laufzeit haben als die exakten. Zunächst müssen wir jedoch einige Grundbegriffe definieren.
   
    Seien $u, v \in \R^d$. Wir definieren $|uv|$ als den euklidischen Abstand von $u$ und $v$.
    Ist $p_i, p_j \in P$, dann ist $\delta(p_i, p_j) \coloneqq \sum\limits_{k=i}^{j-1}{|p_k
    p_{k+1}|}$, also der euklidische Abstand dieser beiden Punkte entlang des Pfades $P$.
	\begin{lemma}
		\label{lem:triangle}
		Für alle Knoten $p_i, p_j \in P$ gilt $|p_ip_j| \leq \delta(p_i, p_j)$
	\end{lemma}
	\begin{proof}
		Dies folgt direkt aus der Dreiecksungleichung in $\R$.
	\end{proof}
	
	\begin{definition}[$t$-distanzerhaltend]
		\label{def:t-dist}
		Sind $p_i, p_j \in P$, dann ist die Kante $(p_i, p_j)$ genau dann \emph{$t$-distanzerhaltend}, wenn $\delta(p_i, p_{i+1}) \leq t \cdot |p_ip_j|$.
	\end{definition}

	\begin{definition}[$t$-distanzerhaltende Approximation]
		\label{def:t-distapp}
		Ein Kantenzug $Q = (p_{i_1}, p_{i_2}, \mathellipsis, p_{i_k})$ ist genau dann eine \emph{$t$-distanzerhaltende Approximation von $P = (p_1, p_2, \mathellipsis, p_n)$}, wenn beide der folgenden Bedingungen gelten.
		\begin{enumerate}
			\item $\displaystyle 1 = i_1 < i_2 < \mathellipsis < i_k = n$
			\item $\displaystyle \text{Für alle } 1 \leq l < k \text{ ist die Kante } (p_{i_l}, p_{i_{l+1}}) \text{ des Pfades $t$-distanzerhaltend}$
		\end{enumerate}
	\end{definition}
	
	Wir nennen eine t-distanzerhaltende Approximation eines Pfades am \emph{kürzesten} bzw. eine \emph{kürzeste}, falls sie die geringst mögliche Zahl an Knoten besitzt.
	Der Quotient $\frac{\delta(p_i, p_j)}{|p_ip_j|}$ heißt \emph{Abweichung} vom Pfad.
	\begin{corollary}
		\label{cor:approximations}
		Sei $1 \leq t < t'$. Dann ist jede $t$-distanzerhaltende Approximation eines Pfades $P$ auch eine $t'$-distanzerhaltende Approximation von $P$.
	\end{corollary}

	In Zusammenhang mit der distanzerhaltenden Kantenzugapproximation stellen sich im Wesentlichen zwei Probleme:
	
	\noindent Das \textbf{Minimum-Vertex-Path-Simplification Problem (MVPS)}: Liegt ein polygonaler Kantenzug $P$ und eine reelle Zahl $t \geq 1$ vor, soll eine kürzeste $t$-distanzerhaltende Approximation von $P$ berechnet werden.
	
	\noindent Das \textbf{Minimum-Dilation-Path-Simplification Problem (MDPS)}: Liegt ein polygonaler Kantenzug $P$ und eine natürliche Zahl $k$ vor, soll der kleinste Wert $t$ bestimmt werden, für den eine $t$-distanzerhaltende Approximation mit maximal $k$ Knoten existiert.

    \begin{figure}
    	\centering
    	\begin{minipage}{.8\linewidth}
    		 \includegraphics[scale=0.15]{approximation_example}
    	\end{minipage}
    	\caption{Kantenzug mit 430 Punkten (oben) und zwei Approximationen mit 126 bzw. 22 Punkten (mitte und unten), die aus dem approximativen Algorithmus für das MVPS-Problem mit jeweils $\epsilon = 0.05$ und $t = 1.05$ bzw. $t = 1.2$ berechnet wurden (Quelle: \cite{gudmundsson})}
    \end{figure}

    \section{Exakte Algorithmen für MVPS und MDPS}
    \label{sec:exact}
    \input{exact_algorithms}
    
    \section{Approximative Algorithmen}
    \label{sec:approximative}
    

    \subsection{Well-separated Pair Decomposition}
    \label{subsec:wspd}
    \input{wspd}
    
    \subsection{Algorithmus für das MVPS-Problem}
    \label{subsec:mvps}
	\input{approximative_mvps}
    
    \subsection{Algorithmus für das MDPS-Problem}
    \label{subsec:mdps}
	Ähnlich wie in Kapitel \ref{sec:exact} werden wir jetzt versuchen, mit Hilfe des eben vorgestellten approximativen Algorithmus für das MVPS-Problem eine Lösung des MDPS-Problems zu konstruieren.
	
	Sei dazu $k$ die Knotenzahl und $P = (p_1, p_2, \mathellipsis, p_n)$ der Kantenzug, für die wir das MDPS-Problem lösen wollen. 
	Wie in Kapitel \ref{sec:exact} sei $t^* = \min\{t \geq 1\ |\ \kappa_t \leq k\}$ die Lösung des Problems. 
	Unser Algorithmus basiert im Wesentlichen auf dem folgenden Lemma.
	
	\begin{lemma}
		\label{lem:tstar}
		Sei $t \geq 1$, $0 < \epsilon < \frac{1}{3}$ und sei $Q$ eine $(1 + \epsilon)t$-distanzerhaltende Approximation, die durch Satz \ref{theo:mvpstime} entstanden ist. Ist $k'$ die Anzahl der Knoten von $Q$, dann gilt:
		\begin{enumerate}
			\item Falls $k' \leq k$, dann ist $t^* \leq (1 + \epsilon) \cdot t$
			\item Falls $k' > k$, dann ist $t^* > t$
		\end{enumerate}
	\end{lemma}
	\begin{proof}
		Zu 1. Sei $k' \leq k$. Sei $t'$ die exakte Abweichung des Kantenzugs $Q$ von $P$, also $max\{\frac{\delta(p_i, p_{i+1})}{|p_ip_{i+1}|}\ |\ 1 \leq i < k\}$. 
		Dann gilt auch $t' \leq (1 + \epsilon) \cdot t$. 
		Aus Lemma \ref{lem:kappa} folgt damit, dass $\kappa_{(1 + \epsilon)t} \leq \kappa_{t'}$.
		Da $\kappa_{t'}$ aber die Knotenzahl einer minimalen $t'$-distanzerhaltenden Approximation ist, muss $\kappa_{t'} \leq k'$ gelten. Zusammen mit der Annahme folgt dann, dass $\kappa_{(1 + \epsilon)t} \leq k$. Wegen Lemma \ref{lem:kappa} muss dann aber $t^* \leq (1 + \epsilon) \cdot t$ gelten.
		
		Zu 2. Sei nun $k' > k$. Nach Satz \ref{theo:mvpstime} gilt $k' \leq \kappa_t$. Also ist auch $k < \kappa_t$. Wie oben folgt nun aus Lemma \ref{lem:kappa}, dass $t^* > t$ sein muss, da für $t^*$ ja $\kappa_{t^*} \leq k$ gilt.		
	\end{proof}
	
	\subsubsection*{Eine erste Approximation von $\mathbf{t^*}$}
	
	Sei nun $0 < \epsilon < \frac{1}{3}$ fest.
	Der folgende Algorithmus berechnet eine Annäherung $\tau$ von $t^*$ bis auf einen Faktor von $2$.
	\begin{description}
		\item{\textbf{Schritt 1:}} Setze $\tau = 2$.
		\item{\textbf{Schritt 2:}} Führe den Algorithmus von Satz \ref{theo:mvpstime} aus. Sei $Q$ die dadurch erhaltende Approximation und $k'$ deren Knotenzahl.
		\item{\textbf{Schritt 3:}} Falls $k' > k$, setze $\tau = 2 \cdot \tau$ und gehe zu Schritt 2.
		Falls $k' \leq k$, gib $\tau$ zurück.
	\end{description}
	
	Dass nach der Terminierung des Algorithmus 
	\[
		\label{eq:tau}
		\frac{\tau}{2} < t^* \leq (1 + \epsilon) \cdot \tau \tag{$\ast$}
	\]
	gilt, folgt direkt aus Lemma \ref{lem:tstar}. 
	Betrachten wir nun noch die Laufzeit des Algorithmus. 
	Der im vorangehenden Kapitel vorgestellte Algorithmus zur Lösung des MVPS-Problems berechnet zunächst einen Split-Tree $T$ und erstellt dann daraus zur gegebenen Trennungsrate $s$ eine WSPD. 
	Da $T$ aber nur vom Eingabe-Kantenzug $P$ abhängt, genügt es, $T$ nur einmal zu berechnen und dann daraus die verschiedenen WSPDs zu erstellen.
	Bei gegebenem $T$ dauert die Lösung des MVPS-Problems für $t$ und $\epsilon$ mit Satz \ref{theo:mvpstime} dann nur noch $O(\frac{t}{\epsilon}\cdot n)$.
	Im obigen Algorithmus wird Schritt 2 $O(log \tau)$ mal ausgeführt, da $\tau$ ja bei jeder Iteration verdoppelt wird.
	Die Laufzeit für die Approximation von $t^*$ bei gegebenem Split-Tree $T$ ist die Folgende:
	\[
	O(\sum_{i=1}^{\log \tau} (\frac{2^i}{\epsilon}\cdot n))
	= O(\frac{\tau}{\epsilon}\cdot n)
	= O(\frac{t^*}{\epsilon}\cdot n)
	\]
	
	\subsubsection*{Eine bessere Approximation von $\mathbf{t^*}$ mit Hilfe von binärer Suche}
	Bevor wir uns einem Algorithmus für eine bessere Approximation von $t^*$ als oben zuwenden, müssen wir zunächst ein dafür essentielles Lemma beweisen.
	
	Sei nun $S = (x_1, x_2, \mathellipsis, x_n)$ wie in Kapitel \ref{subsec:mvps} und $\{A_i, B_i\}_{1 \leq i \leq m}$ eine WSPD mit einer Trennungsrate von 
	\[
	s = \frac{4 + 8(1 + \epsilon)^3 \cdot \tau}{\epsilon}
	\]
	Seien für alle $1 \leq i \leq m$ $a_i$ und $b_i$ feste Elemente aus $A_i$ bzw. $B_i$ und $\alpha_i$ und $\beta_i$ die Knoten von $P$, für die $a_i = \delta(p_1, \alpha_i)$ und $b_i = \delta(p_1, \beta_i)$ ist. 
	Sei $t_i = \frac{\delta(\alpha_i, \beta_i)}{|\alpha_i \beta_i|}$, dann gilt:
	\begin{lemma}
		\label{lem:tstartj}
		Es gibt ein $j$ mit $1 \leq j \leq m$ mit
		\[
			\frac{t_j}{1 + \epsilon} \leq t^* \leq (1 + \epsilon) \cdot t_j
		\]
	\end{lemma}
	\begin{proof}
		Wie wir gesehen haben, gibt es zwei Knoten $p$ und $q$, für die $t^* = \frac{\delta(p, q)}{|pq|}$. Sei $j$ der Index, sodass $\delta(p_1, p) \in A_j$ und $\delta(p_1, q) \in B_j$. Solch ein Index existiert nach Definition der WSPD. Da $(p, q)$ $t^*$-distanzerhaltend ist und wie im Beweis von Lemma \ref{lem:stranget} $t^* < \frac{s^2}{4s + 16}$, ist $s^2 > 4st^* + 16t^*$. 
		Aus selbigem Lemma folgt dann, dass $(\alpha_j, \beta_j)$ $t'$-distanzerhaltend ist, wobei
		\[
		t' = \frac{(1 + \frac{4}{s}) \cdot t^*}{1 - 4(1 + \frac{4}{s})\frac{t^*}{s}}
		\]
		Da außerdem wieder $s \geq 4$, ist wegen unserer speziellen Wahl von $s$
		\[
		t' \leq \frac{(1 + \frac{4}{s}) \cdot t^*}{1 - 8\frac{t^*}{s}}
		\]
		Zusammen mit (\ref{eq:tau}) folgt daraus, dass 
		\[
		s 
		\enspace\geq\enspace \frac{4 + 8(1 + \epsilon)t^*}{\epsilon} 
		\quad \Leftrightarrow \quad
		\frac{(1 + \frac{4}{s})\cdot t^*}{1 - 8 \cdot \frac{t^*}{s}} 
		\enspace\leq\enspace (1 + \epsilon)\cdot t^*
		\]
		Insgesamt ist damit
		\[
		t_j 
		\enspace = \enspace \frac{\delta(\alpha_j, \beta_j)}{|\alpha_j \beta_j|} 
		\enspace\leq\enspace t' 
		\enspace\leq\enspace \frac{(1 + \frac{4}{s}) \cdot t^*}{1 - 8\frac{t^*}{s}}
		\enspace\leq\enspace (1 + \epsilon)\cdot t^*
		\]
		Nun zur zweiten Ungleichung. 
		Wir wissen jetzt, dass $t_j \leq (1 + \epsilon) \cdot t^*$ ist.
		Aus der Beobachtung im ersten Teil des Beweises folgt daraus dann, dass $4st_j + 16t_j < s^2$, insbesondere ist damit wieder die Bedingung aus Lemma \ref{lem:stranget} erfüllt.
		Selbigem Lemma entsprechend ist dann $(p, q)$ $t''$-distanzerhaltend, wobei sich $t''$ ergibt als
		\[
		t'' = \frac{(1 + \frac{4}{s})\cdot t_j}{1 - 4 (1 + \frac{4}{s}) \cdot \frac{t_j}{s}}
		\]
		Wie oben ist $s \geq 4$, sodass sich der Ausdruck zu 
		\[
		t'' = \frac{(1 + \frac{4}{s}\cdot t_j)}{1 - 8 \cdot \frac{t_j}{s}}
		\]
		vereinfacht.
		Da mit \ref{eq:tau} $t_j \leq (1 + \epsilon) \cdot t^* \leq (1 + \epsilon)^2 \tau$ gilt, ist des Weiteren
		\[
		s \geq \frac{4 + 8 (1 + \epsilon) \cdot t_j}{\epsilon}
		\]
		Durch Einsetzen erhalten wir dann $t^* \leq t'' \leq (1 + \epsilon)\cdot t_j$.
	\end{proof}
	
	Nun können wir uns dem eigentlichen Algorithmus zuwenden. Dieser lautet wie folgt:
	
	
	\section{Fazit}
    \label{sec:fazit}

    \bibliography{main}
    \bibliographystyle{plain}

\end{document}
