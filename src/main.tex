%%
%% Author: nikolas
%% 11.03.18
%%

% Preamble
\documentclass[11pt]{article}

% Packages
%\usepackage{a4wide}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage[german]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage[plain]{algorithm}
\usepackage{algorithmic}
%\usepackage{hyperref} % Makes citations clickable


\newcommand{\R}{\mathbb{R}}
\newcommand{\n}{\newline}
\renewcommand{\refname}{Referenzen}
\renewcommand{\baselinestretch}{1.15} % line distance
\renewcommand{\proofname}{\Beweis} % name proofs 'Beweis'


\setitemize{itemsep=0mm} % itemize line distance
\setenumerate{label=(\arabic*),itemsep=0mm} % enumerate labeling and line distance
\allowdisplaybreaks % make math equations breakable

\newtheorem{theorem}{Satz}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}

% Headline
\title{Distanzerhaltende Approximation von Kantenzügen}
\author{Nikolas Klug}
\date{Sommersemester 2018
	\\ Universität Augsburg
	\\ Seminar Algorithmen und Datenstrukturen}


% Document
\begin{document}
    \maketitle

    \begin{abstract}
        Diese Seminararbeit basiert auf \glqq Distance-preserving approximations of polygonal paths\grqq\ von J. Gudmundsson et al. (\cite{gudmundsson}). Sei $P = (p_1, p_2, \mathellipsis p_n)$ ein Kantenzug und $t \geq 1$. Ein Kantenzug $Q$ approximiert $P$, falls er nur aus Punkten von $P$ besteht und falls dessen Kanten jeweils nur um $t$ vom $P$ abweichen. Diese Arbeit stellt exakte und approximative Algorithmen dar, um $Q$ so zu berechnen, dass $Q$ entweder die minimale Zahl von Knoten besitzt, oder für eine feste Knotenzahl 
        minimales $t$ hat.
    \end{abstract}

    \section{Einführung und Definitionen}
    \label{sec:intro}

	Ein \emph{(polygonaler) Kantenzug} $P = (p_1, p_2, \mathellipsis, p_n)$ ist eine Aneinanderreihung von Geradensegmenten, die für $1 \leq i < n$ jeweils $p_i$ und $p_{i+1}$ verbinden. Bei den $p_i$ handelt es sich dabei um Punkte aus dem $\R^d$ (für $d \in \mathbb{N}$). Aufgrund der starken Ähnlichkeit zu gerichteten Pfaden in Graphen, werden wir für Kantenzüge auch häufig Begriffe aus der Graphentheorie verwenden. Beispielsweise heißen die Punkte des Kantenzuges  auch Knoten, die verbindenden Geraden auch (gerichtete) Kanten etc.

    Sei $d\geq1$ und $(p_1, p_2, \mathellipsis, p_n)$ ein Kantenzug $P$, dessen Knoten alle in $\R^{d}$ liegen.
    Ein solcher Kantenzug kann mitunter eine hohe Zahl von Knoten besitzen, die sehr dicht beieinander liegen und leicht durch deutlich weniger Kanten approximiert werden können, wobei sich wichtige Parameter nicht stark ändern. In der Fachliteratur werden dabei zahlreiche Kriterien aufgeführt, einige davon sind die Fläche, die der Pfad einschließt und die Distanz bzw. die Länge des Pfades. In dieser Arbeit soll es um Algorithmen gehen, die einen solchen Pfad unter ungefährer Einhaltung der Länge approximieren. Dabei betrachten wir zunächst zwei exakte Algorithmen und später noch zwei approximative, die eine deutliche bessere Laufzeit haben als die exakten. Zunächst müssen wir jedoch einige Grundbegriffe definieren.
   
    Seien $u, v \in \R^d$. Wir definieren $|uv|$ als den euklidischen Abstand von $u$ und $v$.
    Ist $p_i, p_j \in P$, dann ist $\delta(p_i, p_j) \coloneqq \sum\limits_{k=i}^{j-1}{|p_k
    p_{k+1}|}$, also der euklidische Abstand dieser beiden Punkte entlang des Pfades $P$.
	\begin{lemma}
		\label{lem:triangle}
		Für alle Knoten $p_i, p_j \in P$ gilt $|p_ip_j| \leq \delta(p_i, p_j)$
	\end{lemma}
	\begin{proof}
		Dies folgt direkt aus der Dreiecksungleichung in $\R$.
	\end{proof}
	
	\begin{definition}[$t$-distanzerhaltend]
		\label{def:t-dist}
		Sind $p_i, p_j \in P$, dann ist die Kante $(p_i, p_j)$ genau dann \emph{$t$-distanzerhaltend}, wenn $\delta(p_i, p_{i+1}) \leq t \cdot |p_ip_j|$.
	\end{definition}

	\begin{definition}[$t$-distanzerhaltende Approximation]
		\label{def:t-distapp}
		Ein Kantenzug $Q = (p_{i_1}, p_{i_2}, \mathellipsis, p_{i_j})$ ist genau dann eine \emph{$t$-distanzerhaltende Approximation von $P = (p_1, p_2, \mathellipsis, p_n)$}, wenn beide der folgenden Bedingungen gelten.
		\begin{enumerate}
			\item $\displaystyle 1 = i_1 < i_2 < \mathellipsis < i_j = n$
			\item $\displaystyle \text{Für alle } 1 \leq l < j \text{ ist die Kante } (p_{i_l}, p_{i_{l+1}}) \text{ des Pfades $t$-distanzerhaltend}$
		\end{enumerate}
	\end{definition}
	
	Wir nennen eine t-distanzerhaltende Approximation eines Pfades am \emph{kürzesten} bzw. eine \emph{kürzeste}, falls sie die geringst mögliche Zahl an Knoten besitzt.
	Der Quotient $\frac{\delta(p_i, p_j)}{|p_ip_j|}$ heißt \emph{Abweichung} vom Pfad.
	\begin{lemma}
		\label{lem:approximations}
		Sei $1 \leq t < t'$. Jede $t$-distanzerhaltende Approximation eines Pfades $P$ ist auch eine $t'$-distanzerhaltende Approximation von $P$.
	\end{lemma}
	\begin{proof}
		Dies geht direkt aus Definition \ref{def:t-distapp} hervor.
	\end{proof}
	
	In Zusammenhang mit der distanzerhaltenden Kantenzugapproximation stellen sich im Wesentlichen zwei Probleme:
	
	\noindent Das \textbf{Minimum-Vertex-Path-Simplification Problem (MVPS)}: Liegt ein polygonaler Kantenzug $P$ und eine reelle Zahl $t \geq 1$ vor, soll eine kürzeste $t$-distanzerhaltende Approximation von $P$ berechnet werden.
	
	\noindent Das \textbf{Minimum-Dilation-Path-Simplification Problem (MDPS)}: Liegt ein polygonaler Kantenzug $P$ und eine natürliche Zahl $k$ vor, soll der kleinste Wert $t$ bestimmt werden, für den eine $t$-distanzerhaltende Approximation mit maximal $k$ Knoten existiert.

    Beispiel Bild

    \section{Exakte Algorithmen für MVPS und MDPS}
    \label{sec:exact}
    \input{exact_algorithms}
    
    \section{Approximative Algorithmen}
    \label{sec:approximative}
    

    \subsection{Well-separated Pair Decomposition}
    \label{subsec:wspd}
    \input{wspd}
    
    \subsection{Algorithmus für das MVPS}
    \label{subsec:mvps}
    Nach dem wir jetzt einige Vorarbeit geleistet haben, werden wir in diesem Kapitel sehen, wie man das MVPS-Problem mit Hilfe einer WSPD bis auf ein $\epsilon$ genau approximieren kann - und dass (für festes $t$ und $\epsilon$) in $O(n\log n)$.
    
    \subsubsection*{Die Theorie}
    Sei $P = (p_1, p_2, \mathellipsis, p_n)$ ein Kantenzug in $\R^d$. Für unseren Anwendungsfall genügt es, eine eindimensionale Version $S = (x_1, x_2, \mathellipsis, x_n)$ dieses Pfades zu betrachten. Diese erhalten wir so: Für alle $1 \leq i \leq n$ ist $x_i = \delta(p_1, p_i)$.
    Als nächstes berechnen wir für ein festes $s > 0$ zunächst den Split Tree T und danach eine zugehörige WSPD $\{A_i, B_i\}_{1 \leq i \leq m}$ von $S$. Wegen Eigenschaft (3) der WSPD sind für alle $i$ entweder alle Elemente in $A_i$ kleiner als die in $B_i$ oder umgekehrt. Wir werden o.B.d.A annehmen, dass alle Elemente, die in $A_i$ enthalten sind, kleiner sind, als alle Elemente in $B_i$, da wir einfach bei der Erstellung der WSPD die beiden Mengen passend benennen.
    
    \begin{lemma}
    	\label{lem:stranget}
    	Seien $p, p', q, q' \in P$ und sei $i$ ein solcher Index, dass für $x = \delta(p_1, p)$, $x' = \delta(p_1, p')$, $y = \delta(p_1, q)$ und $y' = \delta(p_1, q')$ $x, x' \in A_i$ und $y, y' \in B_i$ sind. Ist weiter $1 \leq t < \frac{s^2}{4s + 16}$ und ist das Tupel $(p, q)$ $t$-distanzerhaltend, dass ist $(p', q')$ $t'$-distanzerhaltend, wobei $t'$ gegeben ist durch 
    	\[t' = \frac{(1+\frac{4}{s})\cdot t}{1 - 4(1 + \frac{4}{s})\cdot\frac{t}{s}}\]
    \end{lemma}
    \begin{proof}
    	Wegen unserer speziellen Wahl von $t$ ist der Nenner von $t'$ immer positiv, und genauso der Zähler.
    	\begin{align*}
	    	\delta(p', q') &= |x'y'| 
	    	\\ &\leq (1 + \frac{4}{s})\cdot|xy| & \text{(Lemma \ref{lem:wellsep} (2))}
	    	\\ &= (1 + \frac{4}{s})\cdot\delta(p, q)
	    	\\ &\leq (1 + \frac{4}{s})t\cdot |pq| & \text{((p,q) ist $t$-distanzerhaltend)}
	    	\\ &\leq (1 + \frac{4}{s})t\cdot (|pp'| + |p'q'| + |q'q|) & \text{(Dreiecksungleichung in $\R$)}
	    	\\ &\leq (1 + \frac{4}{s})t\cdot (\delta(p,p') + |p'q'| + \delta(q', q)) & \text{(Lemma \ref{lem:triangle})}
	    	\\ &= (1 + \frac{4}{s})t\cdot (|xx'| + |p'q'| + |yy'|)
	    	\\ &\leq (1 + \frac{4}{s})t\cdot (\frac{2}{s}\cdot|x'y'| + |p'q'| + \frac{2}{s}\cdot|x'y'|) & \text{(Lemma \ref{lem:wellsep} (1))}
	    	\\ &= (1 + \frac{4}{s})t\cdot (\frac{4}{s}\cdot\delta(p',q') + |p'q'|)
	    	\\ &= 4(1 + \frac{4}{s})\frac{t}{s}\cdot \delta(p',q') + (1 + \frac{4}{s})t\cdot|p'q'|
    	\end{align*}
    	Also ist
    	\begin{align*}
	    	\delta(p', q') &\leq 4(1 + \frac{4}{s})\frac{t}{s}\cdot \delta(p',q') + (1 + \frac{4}{s})t\cdot|p'q'|
	    	\\ \delta(p', q') \cdot (1 - 4(1 + \frac{4}{s})\frac{t}{s}) &\leq (1 + \frac{4}{s})t\cdot|p'q'| \tag*{\llap{\makebox[\linewidth][l]{$\Leftrightarrow$}}}
	    	\\ \delta(p',q') &\leq t' \cdot |p'q'| \tag*{\llap{\makebox[\linewidth][l]{$\Leftrightarrow$}}}
    	\end{align*}
    \end{proof}
    
    Sei jetzt $0 < \epsilon < \frac{1}{3}$ und $1 \leq t$. Sei 
    \[s = \frac{12 + 24(1 + \frac{\epsilon}{3})\cdot t}{\epsilon}\]
    Durch diese Wahl von $s$ ist die Einschränkung $t < \frac{s^2}{4s + 16}$ von Lemma \ref{lem:stranget} für alle $t > 1$ erfüllt.
    
    \begin{lemma}
    	\label{lem:tepsilon}
    	Seien $p, p', q, q' \in P$ wie in Lemma \ref{lem:stranget}. Dann gilt
    	\begin{enumerate}
    		\item Ist $(p, q)$ $t$-distanzerhaltend, dann ist $(p', q')$ $(1 + \frac{\epsilon}{3})t$-distanzerhaltend.
    		\item Ist $(p, q)$ $(1 + \frac{\epsilon}{3})t$-distanzerhaltend, dann ist $(p', q')$ $(1 + \epsilon)t$-distanzerhaltend.
    	\end{enumerate}
    \end{lemma}
    \begin{proof}
    	Zu 1. Sei $(p, q)$ $t$-distanzerhaltend. Dann ist $(p', q')$ $t'$-distanzerhaltend, wobei $t'$ in Lemma \ref{lem:stranget} gegeben ist. Da die Einschränkung $1 \leq t < \frac{s^2}{4s + 16}$ aus selbigem Lemma immer noch gilt, ist $0 < s^2 - 4st - 16t$. Daraus folgt, dass $s \geq 4t \geq 4$ ist. Es ergibt sich damit und durch unsere spezielle Wahl von s 
    	\[t' \leq \frac{(1 + \frac{4}{s})t}{1 - 8 \frac{t}{s}} = (1+ \frac{\epsilon}{3})t\]
    	Zu 2. Sei $(p, q)$ $(1+ \frac{\epsilon}{3})t$-distanzerhaltend. Dann ist $(p', q')$ $t''$-distanzerhaltend, wobei sich $t''$ aus Lemma \ref{lem:stranget} ergibt als 
    	\[t'' = \frac{(1+\frac{4}{s})\cdot (1 + \frac{\epsilon}{3})t}{1 - 4(1 + \frac{4}{s})\cdot (1 + \frac{\epsilon}{3})\frac{t}{s}}\]
    	Da $1 < \epsilon < \frac{1}{3}$, ist
    	\[
	    	s = \frac{12 + 24(1 + \frac{\epsilon}{3})\cdot t}{\epsilon} \geq \frac{4 (1 + \frac{\epsilon}{3})t}{\epsilon}
    		\geq\frac{4 (1 + \frac{\epsilon}{3})}{\epsilon}
    		\geq\frac{4 (1 + \frac{\epsilon}{3})}{1 - \frac{\epsilon}{3}}
    		\]
    	Desweiteren ist 
    	\begin{align*}    	
	    	s\,\geq\,\frac{4 (1 + \frac{\epsilon}{3})}{1 - \frac{\epsilon}{3}}\qquad
	    	&\Leftrightarrow \qquad s \cdot (2 - (1 + \frac{\epsilon}{3}))\,\geq\, 4 \cdot(1 + \frac{\epsilon}{3})
	    	\\2s \,\geq\, 4 \cdot(1 + \frac{\epsilon}{3}) + s \cdot (1 + \frac{\epsilon}{3}) \qquad
	    	&\Leftrightarrow \qquad 2 \,\geq\, (1 + \frac{4}{s})\cdot(1 + \frac{\epsilon}{3})
	    	\tag*{\llap{\makebox[\linewidth][l]{$\Leftrightarrow$}}}
    	\end{align*}
    	Also ist 
    	\[
	    	t'' \enspace\leq\enspace \frac{(1 + \frac{4}{s})\cdot (1 + \frac{\epsilon}{3})t}{1 - 8 \frac{t}{s}}
	    	\enspace=\enspace (1 + \frac{\epsilon}{3})^2\cdot t \enspace\leq\enspace (1 + \epsilon)\cdot t
    	\]
    \end{proof}
    Seien für alle $1 \leq i \leq m$ $a_i$ und $b_i$ zwei feste Elemente aus $A_i$ und $B_i$. Seien weiter $\alpha_i$ und $\beta_i$ die Elemente von $P$, für die $a_i = \delta(p_1, \alpha_i)$ und $b_i = \delta(p_1, \beta_i)$. Wir nennen im Folgenden die Tupel $(A_i, B_i)$ \emph{$(t, \epsilon)$-distanzerhaltend}, falls jeweils $(\alpha_i, \beta_i)$ $(1 + \frac{\epsilon }{3})t$-distanzerhaltend ist.
    
    Zur Erinnerung: Die Mengen $A_i$ und $B_i$ enthalten die Elemente $x_k = \delta(p_1, p_k)$.
    Als nächstes konstruieren wir aus der WSPD einen gerichteten Graphen $H$. Dabei sind die Knoten von $H$ genau die $2m$ Mengen $A_i$ und $B_i$ und die Kanten sind wie folgt definiert:
    \begin{enumerate}
    	\item Für alle $1 \leq i \leq m$ ist $(A_i, B_i)$ genau dann eine Kante, wenn $(A_i, B_i)$ $(t, \epsilon)$-distanzerhaltend ist und $x_n \in B_i$
    	\item Für alle $1\leq i < j \leq m$ ist $(A_i, A_j)$ genau dann eine Kannte, wenn $(A_i, B_i)$ $(t, \epsilon)$-distanzerhaltend ist und $A_j \cap B_i \neq \emptyset$
    \end{enumerate}

	\begin{theorem}
		\label{theo:Approx2H}
		Jede $t$-distanzerhaltende Approximation $Q = (q_1, q_2, \mathellipsis, q_k)$ von $P$ entspricht einem Pfad $R$ der Länge $k$ in H von einer Menge $A_i$, die $x_1$ enthält, zu einer Menge $B_j$, die $x_n$ enthält
	\end{theorem}
	\begin{proof}
		Sei $y_i$ das Element der Menge $S$, für das $y_i = \delta(p_1, q_i)$ gilt. Da nach Bedingung ja $q_1 = p_1$ gilt, ist also auch $y_1 = x_1$.
		Sei weiter $i_1$ ein solcher Index, für den $y_1 \in A_{i_1}$ und $y_2 \in B_{i_1}$. Dann hat der Pfad $R$ $A_{i_1}$ als ersten Knoten.
		
		Nehmen wir jetzt an, dass wir bereits für ein $l$ mit $1 \leq l < k-1$ den Kantenzug $(q_1, \mathellipsis, q_l)$ zu dem Teilpfad $(A_{i_1}, \mathellipsis, A_{i_l})$ von $R$ umgewandelt haben, sodass $y_l \in A_{i_l}$ und $y_{l+1} \in B_{i_l}$. Wir wählen jetzt $i_{l+1}$ als den Index, für den $y_{l+1} \in A_{i_{l+1}}$ und $y_{l+2} \in B_{i_{l+1}}$ ist. Solch ein Index existiert nach Definition der WSPD. Wir wissen, dass $(q_l, q_{l+1})$ $t$-distanzerhaltend ist und $y_l \in A_{i_l}$ und $y_{l+1} \in B_{i_l} $ liegt. Aus Lemma \ref{lem:tepsilon} (1) folgt dann, dass das Tupel $(A_i, B_i)$ $(t, \epsilon)$-distanzerhaltend ist. Des Weiteren ist der Schnitt von $A_{i_{l+1}}$ mit $B_{i_l}$ nicht leer, da $y_{l+1}$ in beiden Mengen liegt. Es folgt, dass $(A_{i_l}, A_{i_l+1})$ eine Kante in $H$ ist. Wir haben damit also $(q_1, \mathellipsis, q_l, q_{l+1})$ zu dem Pfad $(A_{i_1}, \mathellipsis, A_{i_l}, A_{i_{l+1}})$ umgewandelt, sodass $y_{l+1} \in A_{i_{l+1}}$ und $y_{l+2} \in B_{i_{l+1}}$.
		
		Nehmen wir an, dass wir bereits $(q_1, \mathellipsis, q_l, q_{k-1})$ zu dem Pfad $(A_{i_1}, \mathellipsis, A_{i_{k-1}})$ umgewandelt haben, wobei $y_{k-1} \in A_{i_{k-1}}$ und $y_k \in B_{i_{k-1}}$. Es ist $y_k = \delta(p_1, q_k) = \delta(p_1, p_n) = x_n \in B_{i_{k-1}}$. Da die Kante $(q_{k-1}, q_k)$ $t$-distanzerhaltend ist, ist wieder wegen Lemma \ref{lem:tepsilon} (1) $(A_{i_{k-1}}, B_{i_{k-1}})$ $(t, \epsilon)$-distanzerhaltend und es folgt, dass $(A_{i_{k-1}}, B_{i_{k-1}})$ eine Kante in $H$ ist. Wir fügen $B_{i_{k-1}}$ zum Pfad hinzu, und erhalten als Gesamtergebnis $R = (A_{i_1}, \textellipsis, A_{i_{k-1}}, B_{i_{k-1}})$.
	\end{proof}
	
	Wir haben also gezeigt, dass jede $t$-distanzerhaltende Approximation von $P$ einem Pfad mit der gleichen Zahl von Knoten in $H$ entspricht. Der nächste Satz zeigt, dass dies auch umgekehrt der Fall ist, unter der Einschränkung, dass die Approximation um einen kleinen Teil vom gewünschten $t$-Wert abweichen kann.
	
	\begin{theorem}
		\label{theo:H2Approx}
		Jeder Pfad $R = (A_{i_1}, \textellipsis, A_{i_{k-1}}, B_{i_{k-1}})$ in $H$ mit $x_1 \in A_{i_1}$ und $x_n \in B_{i_{k-1}}$ entspricht einer $(1+\epsilon)t$-distanzerhaltenden Approximation $Q$ von $P$, die $k$ Knoten besitzt.
	\end{theorem}
	\begin{proof}
		Sei wieder $y_i$ das Element der Menge $S$, für das $y_i = \delta(p_1, q_i)$ gilt.
		Da $x_1$ in $A_{i_1}$, können wir als ersten Knoten von $Q$ $q_1 = p_1$ wählen.
		
		Nehmen wir an, dass wir bereits für ein $l$ mit $1 \leq l < k-1$ den Teilpfad $(A_{i_1}, \mathellipsis, A_{i_l})$ zu dem Kantenzug $(q_1, \mathellipsis, q_l)$ umgewandelt haben, sodass $y_1 (= x_1) \in A_{i_1}$ und für alle $1 < j \leq l$ $y_j \in A_{i_j} \cap B_{i_{j-1}}$. Betrachten wir jetzt die Kante $(A_{i_l}, A_{i_{l+1}})$, gibt es ein $y_{l+1} \in A_{i_{l+1}} \cap B_{i_l}$, da der Schnitt nach der Konstruktion von $H$ nicht leer ist. Dann fügen wir das zu $y_{l+1}$ gehörende $q_{l+1}$ zum Kantenzug hinzu und erhalten $(q_1, \mathellipsis, q_l, q_{l+1})$.
		
		Nehmen wir an, dass wir bereits $(A_{i_1}, \mathellipsis, A_{i_k-1})$ bereits zu $(q_1, \mathellipsis, q_{k-1})$ konvertiert haben. Nach Voraussetzung ist $x_n \in B_{k-1}$. Wir wählen dann $q_k = p_n$ und fügen $q_k$ zum Pfad $Q$ hinzu. 
		Insgesamt haben wir also gezeigt, wie man $R$ zu einem Pfad $Q$ mit gleich vielen Knoten umwandeln kann. 
		
		Jetzt bleibt zu zeigen, dass $Q$ auch tatsächlich $(1+\epsilon)t$-distanzerhaltend ist.
		Dazu betrachten wir ein $j$ mit $1 \leq j < k$. Nach unserer Konstruktion von $Q$ ist $y_j \in A_{i_j}$ und $y_{j+1} \in B_{i_j}$. Die Kante $A_{i_j}$ und $B_{i_j}$ ist zudem $(t, \epsilon)$-distanzerhaltend. Mit Lemma \ref{lem:tepsilon} (2) folgt dann, dass alle Tupel $(a, b)$ mit $a \in A_{i_j}$ und $b \in B_{i_{j+1}}$ $(1+\epsilon)t$-distanzerhaltend sind, insbesondere ist also die Kante zwischen den zu $y_j$ und $y_{j+1}$ gehörigen Knoten $(q_j, q_{j+1})$ $(1+\epsilon)t$-distanzerhaltend. Diese Eigenschaft gilt für alle aufeinanderfolgenden Knoten in $Q$, woraus folgt, dass der von uns konstruierte Pfad $Q$ $(1+\epsilon)t$-distanzerhaltend ist.
	\end{proof}
    
    Durch diese beiden Sätze wird schnell klar, was wir tun müssen, um eine $(1+\epsilon)t$-distanzerhaltende Approximation eines Pfades $P$ zu erhalten: Wir konstruieren einfach den Graphen $H$ und führen darin eine Breitensuche zur Lösung des SSSP-Problems aus. Das Problem daran ist aber, dass $H$ $2m = O(n)$ Knoten hat und somit unter Umständen $O(n^2)$ Kanten besitzen kann, was wir uns aber nicht erlauben können, wenn wir eine bessere Laufzeit als die des exakten Algorithmus anstreben.
    
    Bevor wir uns allerdings dem expliziten Algorithmus zuwenden, zeigen wir noch Kriterien, unter denen ein kürzester Pfad in $H$, der den Kriterien aus Satz \ref{theo:H2Approx} genügt, einer kürzesten $t$-distanzerhaltenden Approximation von $P$ entspricht.
    
    \begin{theorem}
    	Sei $P = (p_1, p_2, \mathellipsis, p_n)$ ein polygonaler Kantenzug in $\R^d$ und $H$ der oben definierte Graph. Sei $R = (A_{i_1}, \mathellipsis, A_{i_{k-1}}, B_{i_{k-1}})$ ein kürzester Pfad in $H$ mit $x_1 \in A_{i_1}$ und $x_n \in B_{i_{k-1}}$. Gilt für alle $p, q \in P$ mit $p \neq q$ $\frac{\delta(p, q)}{|pq|} \leq t$ oder $\frac{\delta(p, q)}{|pq|} > (1+\epsilon)t$, so entspricht R einer kürzesten $t$-distanzerhaltenden Approximation von $P$.
    \end{theorem}
    
    \begin{proof}
    	Seien $p, q \in P$, $x = \delta(p_1, p)$ und $y = \delta(p_1, q)$ und $i$ ein solcher Index, dass $x \in A_i$ und $y \in B_i$. 
    	
    	Ist $\frac{\delta(p, q)}{|pq|} > (1+\epsilon)t$, so gilt nach Lemma \ref{lem:tepsilon}, dass für alle $a \in A_i$ und $b \in B$ $\delta(a, b) > (1 + \frac{\epsilon}{3})t \cdot |ab|$. Also ist $(A_i, B_i)$ \emph{nicht} $(t, \epsilon)$-distanzerhaltend und es gibt in $H$ keine Kante, die $A_i$ verlässt.
    \end{proof}
    
    Im Folgenden Abschnitt werden wir deshalb sehen, wie man einen kürzesten Pfad in $H$ finden kann, ohne $H$ zu konstruieren.
    
    \subsubsection*{Der Algorithmus}
    Der Algorithmus besteht aus fünf Teilen, von denen wir die ersten drei schon betrachtet haben.
    Sei $P = (p_1, p_2, \mathellipsis, p_n)$ ein Kantenzug.
    \begin{enumerate}
    	\item Berechne $S = (x_1, x_2, \mathellipsis, x_n)$, wobei $x_i = \delta(p_1, p_i)$ für alle $1 \leq i \leq n$
    	\item Berechne aus $S$ den Split Tree $T$ und daraus eine WSPD $\{A_i, B_i\}_{1 \leq i \leq m'}$ mit der Trennungsrate $s = \frac{12 + 24(1 + \frac{\epsilon}{3})t}{\epsilon}$. Nehme wieder o.B.d.A. an, dass für alle $1 \leq i \leq m'$ alle Elemente aus $A_i$ kleiner sind als alle aus $B_i$.
    	\item Seien $a_i \in A_i$ und $b_i \in B_i$ für alle $1 \leq i \leq m'$ feste Elemente und seien $\alpha_i$ und  $\beta_i$ die Knoten von $P$, für die $a_i = \delta(p_1, \alpha_i)$ und $b_i = \delta(p_1, \beta_i)$. Falls $(\alpha_i, \beta_i)$ nicht $(1+\frac{\epsilon}{3})t$-distanzerhaltend ist, verwirf das korrespondierende Tupel $(A_i, B_i)$, ansonsten behalte es.
    \end{enumerate}
    
    Der Einfachheit halber beschreiben wir die \glqq ausgedünnte\grqq\ WSPD durch $\{A_i, B_i\}_{1\leq i \leq m}$, wobei $m$ die Zahl der verbleibenden Tupel ist.
    Bevor wir zu Schritt (4) kommen, zeigen wir zunächst, wie man mit Hilfe eine Breitensuche in $T$ einen kürzesten Pfad in $H$ bestimmen kann.  
    Für alle $1 \leq i \leq m$ sei $u_i$ der Knoten des Split Trees $T$, der $A_i$ repräsentiert, und $v_i$ derjenige, der $B_i$ repräsentiert. Wir nennen die $u_i$ auch \emph{A-Knoten}. Es ist nicht ausgeschlossen, dass ein Knoten von $T$ mehrere $A_i$ und $B_i$ repräsentiert. Folglich speichert jeder Knoten eine Liste seiner $A_i$ und $B_i$.
    
    Die Breitensuche die wir verwenden, zeigt Ähnlichkeiten zu der, die in \cite{hagerup} erklärt wird. Für jeden Knoten $v$ des Baumes $T$ speichern wir dabei drei Variablen:
    \begin{itemize}
    	\item $color[v]$, die einen Wert aus $\{white, gray, black\}$ hat.
    	\item $dist[v]$, die der aktuellen Distanz von einem Knoten $A_i$ in $H$, der $x_1$ enthält, zum Knoten $v$ speichert.
    	\item $parent[v]$, die den Vater von $w$ im BFS-Wald speichert.
    \end{itemize}
    Sind die Knoten von $T$ mit den Zahlen $1, 2,\mathellipsis, n'$ benannt sind, können wir $color$, $dist$ und $parent$ zum Beispiel durch drei Arrays der Größe $n'$ realisieren.
    Die Breitensuche sieht dann so aus:
    
    \begin{description}
    	\item[\textbf{Schritt 1:}] Für alle Knoten $k$ von $T$, setze $color[k] = white$, $dist[k] = \infty$ und $parent[k] = null$.
    	
    	\item[\textbf{Schritt 2:}] Initialisiere eine leere Warteschlange $W$ (z.B durch eine verkettete Liste).
    	Starte bei dem Blatt, dass $x_1$ speichert (dem \glqq linkesten\grqq\ Blatt) und laufe im Baum aufwärts bis zur Wurzel. 
    	Für alle besichtigten Knoten $k$, tue Folgendes: 
    	
		    Setze $color[k] = gray$.
    		Falls $k$ ein A-Knoten ist, setze $dist[k] = 0$.
    		Füge $k$ in $W$ ein.
    		
    	\item[\textbf{Schritt 3:}] Entferne das erste Element $k$ von $W$. Setze $color[k] = black$.
    	Für alle $u_i = k$ tue Folgendes:
    	
    	Falls $x_n \in B_i$, setze $dist[v_i] = dist[k] + 1$, $parent[v_i] = k$, $z = v_i$ und gehe zu Schritt 4.\n
    	Falls $x_n \notin B_i$ und $color[v_i] == white$, führe die Schritte 3.1 und 3.2 aus.
    	\begin{description}
    		\item[\textbf{Schritt 3.1:}] Starte bei $v_i$ und laufe im Baum aufwärts bis zum ersten nicht weißen Knoten. Für alle besichtigten Knoten $k'$, tue Folgendes:
    		
    		Setze $color[k'] = gray$. Falls $k'$ ein A-Knoten ist, setze $dist[k'] = dist[k]+1$, $parent[k'] = k$ und füge $k'$ in $W$ ein.
    		
    		\item[\textbf{Schritt 3.2:}] Starte bei $v_i$ und besuche alle Knoten des Teilbaums von $T$, dessen Wurzel $v_i$ ist. Für alle besichtigten Knoten $k'$, tue Folgendes:
    		
    		Setze $color[k'] = gray$. Falls $k'$ ein A-Knoten ist, setze $dist[k'] = dist[k] + 1$, $parent[k']	= k$ und füge $k'$ in $W$ ein.
    	\end{description}
    	
    	\item[\textbf{Schritt 4:}] Berechne den Pfad $Z = (z, parent[z], parent[parent[z]], parent^3[z],  \mathellipsis, parent^{k-1}[z])$, wobei $k = dist[z] + 1$. Gib den umgekehrten Pfad $Z' = (parent^{k-1}[z], \mathellipsis,, parent[z], z)$ zurück.
    \end{description}
    
    Dass diese Breitensuche einen kürzesten Pfad in $H$ zurückgibt, ist nicht sofort klar. Auf einen vollständigen Beweis wollen wir an dieser Stelle verzichten, aber die wichtigsten Punkte skizzieren. 
    
    Ist $k$ das erste Element der Warteschlange, so hat es die momentan kleinste Distanz zu einer Menge $A_i$, die $x_1$ enthält. Sei $A_l$ eine Menge, für die $u_l = k$ gilt. Wird jetzt $u_l$ bearbeitet, werden alle anderen von $A_l$ aus (in $H$) erreichbaren Mengen $A_j$ betrachtet. Diese Mengen sind genau die, die einen nicht-leeren Schnitt mit $B_l$ haben. 
    
	Wir können beobachten, dass, falls für einen Knoten $u$ $color[u] = white$, alle Knoten im Unterbaum von $u$ weiß sind. Ist $v$ der erste nicht-weiße Knoten, der in Schritt 3.1 erreicht wird, sind alle Knoten auf dem Pfad von $v$ zur Wurzel des Split Trees nicht-weiß.
    
    Dadurch ist klar, dass in den Schritten 3.1 und 3.2 alle Mengen $A_j$ bearbeitet werden, die von $A_l$ aus erreichbar sind.. Für jedes $A_j$ wird dann dessen Distanz zu $A_i$ verringert (nämlich von $\infty$ auf $d[k]+1$). 
    
    Ist jedoch $x_n$ im zu $A_l$ gehörigen $B_l$ bereits enthalten, ist die Breitensuche beendet, da dann bereits ein kürzester Weg von $A_i$ zu $B_l$ bestimmt wurde.
    
    Ein genauer, vollständiger Beweis kann unter Verwendung der obigen Beobachtungen analog zum Beweis der Breitensuchen im Informatik III Skript \cite{hagerup} oder zu dem in Cormen et al. \cite{cormen} durchgeführt werden. Ist $m$ die Kantenzahl in $T$ und $z$ die Knotenzahl, ergibt sich dabei insbesondere die für eine Breitensuche übliche Laufzeit $O(m + z)$. Aber $O(m + z) = O(sn) = O(\frac{t}{\epsilon}n)$. Darum erhalten wir für die Laufzeit der Breitensuche insgesamt $O(\frac{t}{\epsilon}n)$.
    
    Die letzten beiden Teile des Algorithmus sind dann folgende:
    \begin{enumerate}[start=4, topsep=4mm]
    	\item Führe die oben aufgeführte modifizierte Breitensuche in $T$ durch, um einen kürzesten Pfad $Z'$ von einer Menge $A_{i_1}$, die $x_1$ enthält, zu einer Menge $B_{i_{k-1}}$, die $x_n$ enthält, zu bestimmen.
    	\item Konvertiere $Z'$, der den Kriterien von Satz \ref{theo:H2Approx} entspricht, wie im Beweis desselben Satzes zu einer Approximation von $P$.
    \end{enumerate}
    Abschließend betrachten wir noch die Laufzeit des Algorithmus. $S$ zu berechnen kostet uns $O(n)$ Zeit. Nach Satz \ref{theo:wspdtime} können wir Teil 2 in $O(n \log n + sn)$ schaffen, und da $O(sn) = O(\frac{t}{\epsilon}\cdot n)$, dauert dieser Teil also $O(n \log n + \frac{t}{\epsilon}n)$. Somit dauert auch Teil 3 $O(\frac{t}{\epsilon}n)$, da wir jedes Tupel der WSPD einmal betrachten. Wie oben gesehen weißt die Breitensuche dieselbe asymptotische Laufzeit auf. 
    
    Nun bleibt noch der letzte Teil des Algorithmus. 
    Um den Pfad in $H$ zu konvertieren, wählen wir, wie gezeigt, $p_1$ als ersten und $p_n$ als letzten Knoten. 
    Einer der wichtigen Schritte für die restlichen Knoten besteht darin, ein Element aus $A_{i_{l+1}} \cap B_{i_l}$ auszuwählen. 
    Da wir wissen, dass der Schnitt nicht leer ist, und $A_{i_{l+1}}$ und $B_{i_l}$ durch Knoten des Baumes repräsentiert werden (nämlich $u_{i_{l+1}}$ und $v_{i_l}$), die wiederum die Blätter in ihrem jeweiligen Unterbaum zusammenfassen, muss entweder $A_{i_{l+1}}\subseteq B_{i_l}$ sein oder umgekehrt. 
    Also wählen wir zum Beispiel das Minimum $min$ des Intervalls, das mit $u_{i_{l+1}}$ gespeichert ist, und überprüfen, ob es im Intervall von $v_{i_l}$ liegt. 
    Ist dass der Fall, liegt dieses im Schnitt und wir wählen den zu $min$ gehörigen Knoten als nächsten. Sonst ist $B_{i_l}\subset A_{i_{l+1}}$ und wir können das Minimum des Intervalls von $v_{i_l}$ wählen. Dieses Vorgehen dauert für jede Kante $(A_{i_l}, A_{i_{l+1}})$ jeweils konstante Zeit, insgesamt kostet und Teil 5 des Algorithmus also $O(n)$ Zeit.
    Zusammenfassend können wir festhalten:
    
    \begin{theorem}
    	\label{theo:mvpstime}
    	Sei $P = (p_1, p_2, \mathellipsis, p_n)$ ein Kantenzug in $\R^d$, sei $t \geq 1$ und $0 < \epsilon < \frac{1}{3}$ und sei $\kappa$ die Knotenzahl der kürzesten t-distanzerhaltenden Approximationen von $P$.
    	\begin{enumerate}
    		\item Dann können wir in $O(n \log n + \frac{t}{\epsilon}n)$ eine $(1 + \epsilon)t$-distanzerhaltende Approximation $Q$ von $P$ mit maximal $\kappa$ Knoten berechnen.
    		\item Ist weiter für alle verschiedenen $p, q \in P$ $\frac{\delta(p,q)}{|pq|} \leq t$ oder $\frac{\delta(p,q)}{|pq|} > (1 + \epsilon)t$, dann ist $Q$ sogar eine $t$-distanzerhaltende Approximation von $P$ mit $\kappa$ Knoten.
    	\end{enumerate}
    	
    \end{theorem}
    
    \subsection{Algorithmus für das MDPS}
    \label{subsec:mdps}
    Heuristischer Algorithmus aus Paper mit allen Erklärungen

    \section{Fazit}
    \label{sec:fazit}

    \bibliography{main}
    \bibliographystyle{plain}

\end{document}
