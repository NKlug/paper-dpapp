%%
%% Author: nikolas
%% 11.03.18
%%

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{a4wide}
\usepackage[german]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
%\usepackage{hyperref} % Makes citations clickable

\newcommand{\R}{\mathbb{R}}
\newcommand{\n}{\newline}
\renewcommand{\refname}{Referenzen}
\renewcommand{\baselinestretch}{1.15}
\renewcommand{\proofname}{\Beweis}

\newtheorem{theorem}{Satz}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}

% Headline
\title{Distanzerhaltende Approximation von Kantenzügen}
\author{Nikolas Klug}


% Document
\begin{document}
    \maketitle

    \begin{abstract}
        asdf
    \end{abstract}

    \section{Einführung und Definitionen}
    \label{sec:intro}

    Sei $d\geq1$ und $p_1, p_2, \mathellipsis, p_n$ ein Pfad $P$, dessen Knoten alle in $\R^{d}$ liegen.
    Ein solcher Pfad kann mitunter eine hohe Zahl von Knoten besitzen, die sehr nah beieinander liegen und leicht durch deutlich weniger Kanten approximiert werden können, wobei sich wichtige Parameter nicht stark ändern. In der Fachliteratur werden dabei zahlreiche Kriterien aufgeführt, einige davon sind die Fläche, die der Pfad einschließt und die Distanz bzw.\ die Länge des Pfades. In dieser Arbeit soll es um Algorithmen gehen, die einen solchen Pfad unter Einhaltung der Länge approximieren.
    Art der Approximationen:
    - Flächenerhaltende Approximation + Anwendungen\n
    - Distanzerhaltende Approximatioin + Anwendungen\n
    - tolerance zone, infinite beam, uniform measure\textellipsis\n
    (- Vor- und Nachteile)


    Seien $u, v \in \R^d$, dann definieren wir $|uv|$ als den euklidischen Abstand
    (bzw.\ als die $L2-Norm$) dieser beiden Punkte.
    Sind $v_i, v_j \in P$ dann sei $\delta(v_i, v_j) \coloneqq \sum\limits_{i=1}^{n-1}{|v_i
    v_{i+1}|}$, also der euklidische Abstand dieser beiden Punkte entlang des Pfades $P$

    - Definition $t$-distanzerhaltend\n
    - Definition $t$-distanzerhaltende Approximation\n
    - Definition MVPS\n
    - Definition MDPS\n

    Beispiel Bild

    \section{Exakte Algorithmen für MVPS und MDPS}
    \label{sec:exact}
    
    Zu Beginn betrachten wir zwei einfache exakte Algorithmen.
    Sei wieder $d\geq1$, $t>1$ und $P = (p_1, p_2, \mathellipsis, p_n)$ ein Pfad in $\R^d$. Sei weiter $P^*$ die Menge der $t$-distanzerhaltenden Approximationen, die die geringste Knotenzahl besitzen.
    
    Wir konstruieren jetzt den gerichteten Graphen $G_t = (V,E_t)$, wobei V genau aus den Knoten des Pfades $P$ besteht und 
    $E_t = \{(p_i, p_j) \in V\times V|\ i < j \text{ und } (p_i,p_j)\ \text{ist $t$-distanzerhaltend}\}$. $E_t$ ist also gerade die Menge aller $t$-distanzerhaltenden Kanten zwischen Knoten aus $V$. Zunächst beobachten wir, dass jede $t$-distanzerhaltende Approximation von $P$ einem Pfad in $G_t$ entspricht, da $G_t$ alle $t$-distanzerhaltenden Kanten zwischen Knoten von $P$ enthält. Andererseits ist auch jeder Pfad $Q = (p_{i_1}, p_{i_2}, \mathellipsis, p_{i_k})$ mit $1 = i_1 < i_2 < \mathellipsis < i_k = n$ in $G_t$ eine $t$-distanzerhaltende Approximation von $P$, da nur $t$-distanzerhaltende Kanten verwendet werden. Daraus folgt, dass auch $P^*$ in $G_t$ liegt. Jetzt müssen wir also nur noch ein Element aus $P^*$ ermitteln. Das ist leicht: Wir führen eine Breitensuche in $G_t$ mit Startknoten $p_1$ durch, bei der wir jeden Knoten mit der Nummer des Knotens beschriften, von dem aus er zum ersten Mal entdeckt wurde. Am Ende lesen wir diese Beschriftung bei $p_n$ beginnend solange aus, bis wir $p_1$ erreichen. Der dadurch enstandene Pfad ist dann aufgrund der Eigenschaften der Breitensuche in $P^*$. 
    Nun betrachten wir noch die Laufzeit: Die Konstruktion von $G_t$ gelingt uns in $O(n^2)$, da wir für maximal $\binom{n}{2} = O(n^2)$ Kanten überprüfen müssen, ob diese $t$-distanzerhaltend sind. Sei $m$ die Zahl der Kanten in $G_t$, dann wissen wir aus  \cite{hagerup}, dass die Breitensuche $O(n+m)$ Zeit dauert. In unserem Fall ist $O(m) = O(n^2)$, und somit dauert die Breitensuche auch $O(n^2)$. Insbesondere haben wir:
    \begin{theorem}
    	\label{theo:mvpsex}
    	Das Minimum Vertex Path Simplification Problem kann für Pfade mit n Knoten $O(n^2)$ gelöst werden.
    \end{theorem} 
    
    Als nächstes wollen wir uns überlegen, wie man das MDPS-Problem für eine feste Anzahl von Knoten $k$ lösen kann. Sei im Folgenden $\kappa_t$ die geringst mögliche Zahl von Knoten für eine $t$-distanzerhaltende Approximation von $P$.
	\begin{lemma}
		\label{lem:kappa}
		Sind $t, t' \in \R$ und $t < t'$, dann ist $\kappa_t \geq \kappa_{t'}$.
	\end{lemma}
	\begin{proof}
		Die Kantenmenge $E_t$ ist eine Teilmenge von $E_{t'}$, da alle Kanten, die $t$-distanzerhaltend sind, auch $t'$-distanzerhaltend sind. Somit ist jede $t$-distanzerhaltende Approximation auch eine $t'$-distanzererhaltende Approximation, es folgt also $\kappa_t \geq \kappa_{t'}$.
	\end{proof}
	
	Da $G_t$ maximal $O(n^2)$ Kanten enthält, gibt es eine endliche Zahl von $t$-Werten. Wir müssen also nur noch aus diesen Werten den geringsten Wert $t^*$ ermitteln, der gerade noch k Knoten oder weniger hat. Dazu definieren wir zunächst für $1\leq i < j \leq n$ $t^*_{ij} \coloneqq\frac{\delta(p_i, p_j)}{|p_i p_j|}$, also als die Abweichung der Kante $(p_i, p_j)$ vom Pfad. Sei nun $M\coloneqq\{t^*_{ij}\ |\ 1\leq i < j \leq n\}$. Wir wissen, dass $t^* \in M$, da die gesuchte Approximation eine Kante mit maximalen $t$-Wert hat, und $M$ gerade alle diese enthält. Wegen Lemma \ref{lem:kappa} wissen wir, das sich die $\kappa_t$ umgekehrt proportional zu den $t$-Werten verhalten. Sortieren wir jetzt $M$ zu $M'$, können wir in $M'$ nach dem $t*$ suchen. Dazu verwenden wir eine Binärsuche, bei der wir jeweils für den aktuell betrachteten $t$-Wert das MVPS lösen. Da $M$ $O(n^2)$ Elemente enthält, können wir $M$ nach \cite{hagerup} in $O(n^2\log n^2)=O(n^2\log n)$ sortieren.
	Die Binärsuche dauert bekanntermaßen $O(\log n)$ und mit Satz \ref{theo:mvpsex} ergibt sich auch dafür eine Laufzeit von $O(n^2\log n)$. Wir halten fest:
	\begin{theorem}
		Das Minimum Dilation Path Simplification Problem kann für Pfade mit n Knoten in $O(n^2 \log n)$ gelöst werden.
	\end{theorem}
	
	Damit beschließen wir das Kapitel über exakte Algorithmen für das MVPS- und das MDPS-Problem und wenden uns approximativen zu.

    \section{Approximative Algorithmen}
    \label{sec:approximative}
    

    \subsection{Well-separated Pair Decomposition}
    \label{subsec:wspd}
    
    \begin{definition}[well-separated]
    	Sei $s > 0$ und $A$ und $B$ zwei endliche Mengen von Punkten im $\R^d$. $A$ und $B$ heißen well-separated with respect to $s$, falls es zwei disjunkte Bälle $C_A$ und $C_B$ gibt, die denselben Radius $R$ haben, wobei $A \subseteq C_A$ und $B \subseteq C_B$ und die euklidische Distanz zwischen $C_A$ und $C_B$ mindestens $s\cdot R$ beträgt.
    \end{definition}
    
    \begin{definition}[well-separated pair decomposition]
    	Sei $S \subseteq \R^d$ und $s > 0$. Eine Folge $(A_i, B_i)_{1 \leq i \leq m}$ von nicht-leeren Teilmengen von S ist genau dann eine well-separated pair decompositon (WSPD), wenn gilt:
    	\begin{enumerate}[label={(\arabic*)}]
    		\item $A_i \cap B_i = \emptyset$
    		\item Für alle $p, q \in S$ gibt es genau einen Index $1 \leq i \leq m$, sodass entweder $p \in A_i$ und $q \in B_i$ oder $q \in A_i$ und $p \in B_i$.
    		\item $A_i$ und $B_i$ sind well-separated with respect to $s$
    	\end{enumerate}
    \end{definition}


    \subsection{Algorithmus für das MVPS}
    \label{subsec:mvps}
    
    \subsection{Algorithmus für das MDPS}
    \label{subsec:mdps}
    Heuristischer Algorithmus aus Paper mit allen Erklärungen

    \section{Fazit}
    \label{sec:fazit}

    \bibliography{main}
    \bibliographystyle{plain}

\end{document}
