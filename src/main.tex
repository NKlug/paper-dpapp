%%
%% Author: nikolas
%% 11.03.18
%%

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{a4wide}
\usepackage[german]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
%\usepackage{hyperref} % Makes citations clickable

\newcommand{\R}{\mathbb{R}}
\newcommand{\n}{\newline}
\renewcommand{\refname}{Referenzen}
\renewcommand{\baselinestretch}{1.15}
\renewcommand{\proofname}{\Beweis}

\newtheorem{theorem}{Satz}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}

% Headline
\title{Distanzerhaltende Approximation von Kantenzügen}
\author{Nikolas Klug}


% Document
\begin{document}
    \maketitle

    \begin{abstract}
        asdf
    \end{abstract}

    \section{Einführung und Definitionen}
    \label{sec:intro}

    Sei $d\geq1$ und $p_1, p_2, \mathellipsis, p_n$ ein Kantenzug $P$, dessen Knoten alle in $\R^{d}$ liegen.
    Ein solcher Pfad kann mitunter eine hohe Zahl von Knoten besitzen, die sehr nah beieinander liegen und leicht durch deutlich weniger Kanten approximiert werden können, wobei sich wichtige Parameter nicht stark ändern. In der Fachliteratur werden dabei zahlreiche Kriterien aufgeführt, einige davon sind die Fläche, die der Pfad einschließt und die Distanz bzw.\ die Länge des Pfades. In dieser Arbeit soll es um Algorithmen gehen, die einen solchen Pfad unter Einhaltung der Länge approximieren.
    Art der Approximationen:
    - Flächenerhaltende Approximation + Anwendungen\n
    - Distanzerhaltende Approximatioin + Anwendungen\n
    - tolerance zone, infinite beam, uniform measure\textellipsis\n
    (- Vor- und Nachteile)


    Seien $u, v \in \R^d$, dann definieren wir $|uv|$ als den euklidischen Abstand
    (bzw.\ als die $L2-Norm$) dieser beiden Punkte.
    Sind $v_i, v_j \in P$ dann sei $\delta(v_i, v_j) \coloneqq \sum\limits_{i=1}^{n-1}{|v_i
    v_{i+1}|}$, also der euklidische Abstand dieser beiden Punkte entlang des Pfades $P$

    - Definition $t$-distanzerhaltend\n
    - Definition $t$-distanzerhaltende Approximation\n
    - Definition MVPS\n
    - Definition MDPS\n

    Beispiel Bild

    \section{Exakte Algorithmen für MVPS und MDPS}
    \label{sec:exact}
    
    Zu Beginn betrachten wir zwei einfache exakte Algorithmen.
    Sei wieder $d\geq1$, $t>1$ und $P = (p_1, p_2, \mathellipsis, p_n)$ ein Pfad in $\R^d$. Sei weiter $P^*$ die Menge der $t$-distanzerhaltenden Approximationen, die die geringste Knotenzahl besitzen.
    
    Wir konstruieren jetzt den gerichteten Graphen $G_t = (V,E_t)$, wobei V genau aus den Knoten des Pfades $P$ besteht und 
    $E_t = \{(p_i, p_j) \in V\times V|\ i < j \text{ und } (p_i,p_j)\ \text{ist $t$-distanzerhaltend}\}$. $E_t$ ist also gerade die Menge aller $t$-distanzerhaltenden Kanten zwischen Knoten aus $V$. Zunächst beobachten wir, dass jede $t$-distanzerhaltende Approximation von $P$ einem Pfad in $G_t$ entspricht, da $G_t$ alle $t$-distanzerhaltenden Kanten zwischen Knoten von $P$ enthält. Andererseits ist auch jeder Pfad $Q = (p_{i_1}, p_{i_2}, \mathellipsis, p_{i_k})$ mit $1 = i_1 < i_2 < \mathellipsis < i_k = n$ in $G_t$ eine $t$-distanzerhaltende Approximation von $P$, da nur $t$-distanzerhaltende Kanten verwendet werden. Daraus folgt, dass auch $P^*$ in $G_t$ liegt. Jetzt müssen wir also nur noch ein Element aus $P^*$ ermitteln. Das ist leicht: Wir führen eine Breitensuche in $G_t$ mit Startknoten $p_1$ durch, bei der wir jeden Knoten mit der Nummer des Knotens beschriften, von dem aus er zum ersten Mal entdeckt wurde. Am Ende lesen wir diese Beschriftung bei $p_n$ beginnend solange aus, bis wir $p_1$ erreichen. Der dadurch enstandene Pfad ist dann aufgrund der Eigenschaften der Breitensuche in $P^*$. 
    Nun betrachten wir noch die Laufzeit: Die Konstruktion von $G_t$ gelingt uns in $O(n^2)$, da wir für maximal $\binom{n}{2} = O(n^2)$ Kanten überprüfen müssen, ob diese $t$-distanzerhaltend sind. Sei $m$ die Zahl der Kanten in $G_t$, dann wissen wir aus  \cite{hagerup}, dass die Breitensuche $O(n+m)$ Zeit dauert. In unserem Fall ist $O(m) = O(n^2)$, und somit dauert die Breitensuche auch $O(n^2)$. Insbesondere haben wir:
    \begin{theorem}
    	\label{theo:mvpsex}
    	Das Minimum Vertex Path Simplification Problem kann für Pfade mit n Knoten $O(n^2)$ gelöst werden.
    \end{theorem} 
    
    Als nächstes wollen wir uns überlegen, wie man das MDPS-Problem für eine feste Anzahl von Knoten $k$ lösen kann. Sei im Folgenden $\kappa_t$ die geringst mögliche Zahl von Knoten für eine $t$-distanzerhaltende Approximation von $P$.
	\begin{lemma}
		\label{lem:kappa}
		Sind $t, t' \in \R$ und $t < t'$, dann ist $\kappa_t \geq \kappa_{t'}$.
	\end{lemma}
	\begin{proof}
		Die Kantenmenge $E_t$ ist eine Teilmenge von $E_{t'}$, da alle Kanten, die $t$-distanzerhaltend sind, auch $t'$-distanzerhaltend sind. Somit ist jede $t$-distanzerhaltende Approximation auch eine $t'$-distanzererhaltende Approximation, es folgt also $\kappa_t \geq \kappa_{t'}$.
	\end{proof}
	
	Da $G_t$ maximal $O(n^2)$ Kanten enthält, gibt es eine endliche Zahl von $t$-Werten. Wir müssen also nur noch aus diesen Werten den geringsten Wert $t^*$ ermitteln, der gerade noch k Knoten oder weniger hat. Dazu definieren wir zunächst für $1\leq i < j \leq n$ $t^*_{ij} \coloneqq\frac{\delta(p_i, p_j)}{|p_i p_j|}$, also als die Abweichung der Kante $(p_i, p_j)$ vom Pfad. Sei nun $M\coloneqq\{t^*_{ij}\ |\ 1\leq i < j \leq n\}$. Wir wissen, dass $t^* \in M$, da die gesuchte Approximation eine Kante mit maximalen $t$-Wert hat, und $M$ gerade alle diese enthält. Wegen Lemma \ref{lem:kappa} wissen wir, das sich die $\kappa_t$ umgekehrt proportional zu den $t$-Werten verhalten. Sortieren wir jetzt $M$ zu $M'$, können wir in $M'$ nach $t^*$ suchen. Da $M$ $O(n^2)$ Elemente enthält, können wir $M$ nach \cite{hagerup} in $O(n^2\log n^2)=O(n^2\log n)$ sortieren. Für die Suche verwenden wir eine Binärsuche, bei der wir jeweils für den aktuell betrachteten $t$-Wert das MVPS lösen und dann abhängig vom Ergebnis entweder im rechten oder linken Teilbereich weitersuchen. 
	Eine gewöhnliche Binärsuche dauert bekanntermaßen $O(\log n)$ und mit Satz \ref{theo:mvpsex} ergibt sich auch hier eine Laufzeit von $O(n^2\log n)$. Wir halten fest:
	\begin{theorem}
		Das Minimum Dilation Path Simplification Problem kann für Pfade mit n Knoten in $O(n^2 \log n)$ gelöst werden.
	\end{theorem}
	
	Damit beschließen wir das Kapitel über exakte Algorithmen für das MVPS- und das MDPS-Problem und wenden uns approximativen Lösungen zu.

    \section{Approximative Algorithmen}
    \label{sec:approximative}
    

    \subsection{Well-separated Pair Decomposition}
    \label{subsec:wspd}
    
    \begin{definition}[well-separated]
    	\label{def:wellsep}
    	Sei $s > 0$ und $A$ und $B$ zwei endliche Mengen von Punkten im $\R^d$. $A$ und $B$ heißen well-separated with respect to $s$, falls es zwei disjunkte Bälle $C_A$ und $C_B$ gibt, die denselben Radius $R$ haben, wobei $A \subseteq C_A$ und $B \subseteq C_B$ und die euklidische Distanz zwischen $C_A$ und $C_B$ mindestens $s\cdot R$ beträgt.
    \end{definition}
    
    Das folgende Lemma hält zwei wichtige Eigenschaften von zwei wohl-separierten Mengen $A$ und $B$ fest.
    \begin{lemma}
		Seien $a, a' \in A$ und $b, b' \in B$. Dann gilt:
		\begin{enumerate}[label={(\arabic*)}]
			\item \[|aa'| \leq \frac{2}{s}\cdot|a'b'|\]
			\item \[|a'b'| \leq (1+\frac{4}{s})\cdot|ab|\]
		\end{enumerate}
    \end{lemma}
    \begin{proof}
    	Zu 1. Ist $r$ der Radius der beiden Mengen, so gilt $|aa'| \leq 2 \cdot r$. Da $A$ und $B$ wohl-separiert sind, gilt $|a'b'| \geq s \cdot r$, was äquivalent ist zu $r \leq \frac{|a'b'|}{s}$. Durch Einsetzen folgt dann die Behauptung.
    	Zu 2. Da $A$ und $B$ wohl-separiert in Bezug zu $s$ sind, und $C_A$ und $C_B$ beide denselben Radius $r$ haben, gilt $|a'b'| \leq s \cdot r + 4 \cdot r$. Ausklammern rechts ergibt $(1 + \frac{4}{s}) \cdot s \cdot r$. Da ja auch $s \cdot r \leq |ab|$, folgt durch Einsetzen die Behauptung.
    \end{proof}
    
    \begin{definition}[well-separated pair decomposition]
    	\label{def:wspd}
    	Sei $S \subseteq \R^d$ und $s > 0$. Eine Folge $(A_i, B_i)_{1 \leq i \leq m}$ von nicht-leeren Teilmengen von S ist genau dann eine \emph{well-separated pair decompositon (WSPD)}, wenn gilt:
    	\begin{enumerate}[label={(\arabic*)}, itemsep=0mm]
    		\item $A_i \cap B_i = \emptyset$
    		\item Für alle $p, q \in S$ gibt es genau einen Index $1 \leq i \leq m$, sodass entweder $p \in A_i$ und $q \in B_i$ oder $q \in A_i$ und $p \in B_i$.
    		\item $A_i$ und $B_i$ sind well-separated with respect to $s$
    	\end{enumerate}
    \end{definition}
	
	\noindent	$m$ nennen wir dabei die \emph{Größe} der WSPD.

	Die WSPD bildet eine wichtige Grundlage für die beiden Algorithmen, die wir im Folgenden betrachten werden. \textellipsis haben gezeigt, dass man eine WSPD der Größe $m = O(n)$ in $O(n\log n)$ Zeit berechnen kann. Dabei wird zunächst ein sogenannter \emph{fairer Split Tree} berechnet, aus dem dann in $O(s^dn)$ Zeit eine WSPD erstellt werden kann. Wir werden sehen, dass es für unseren Anwendungsfall genügt, eine WSPD für Mengen von Punkten aus $\R$ zu erstellen. Für diesen 1-dimensionalen Fall kann der faire Split Tree mit Hilfe eines einfachen Algorithmus berechnet werden.
	
	Sei $S'$ eine endliche Teilmenge von $\R$ und $|S'| = n$. Wir können davon ausgehen, dass uns diese Menge sortiert in einem Array $S[1..n]$ vorliegt und werden später sehen, dass das bei unserem Algorithmus auch tatsächlich der Fall ist. ABBILDUNG X stellt einen Algorithmus dar, der diesen Split Tree $T$ erstellt. Bei $T$ handelt es sich um einen Binärbaum, an dessen Blättern die Werte von $S$ in von links nach rechts aufsteigend sortierter Reihenfolge gespeichert sind. Für jeden inneren Knoten wird zusätzlich das Intervall in dem die Blätter des von ihm induzierten Teilbaumes liegen gepsiechert.
	Da $T$ $n$ Blätter hat, erstellen wir $O(n)$ Knoten. Dabei müssen wir aber in ZEILE 88 jedesmal eine Binärsuche durchführen, die $O(\log n)$ Zeit kostet. Somit ergibt sich für das Erstellen von $T$ eine Gesamtlaufzeit von $O(n\log n)$.
	Betrachten wir jetzt zwei innere Knoten $p$ und $q$ von T. Seien $[i, j]$ und $[k, l]$ die Intervalle, die wir mit $p$ und $q$ gespeichert haben und 
	\[R \coloneqq \max(i - j, k - l)\]
	Nach Definition \ref{def:wellsep} sind die beiden Intervalle genau dann wohl-separiert, wenn 
	\[k - j \geq R \cdot s \text{ oder } i - l \geq R \cdot s \]
	Der in ABBILDUNG XX dargestellte Algorithmus berechnet dann aus dem fairen Split-Tree eine WSPD. Wie XY und ZA gezeigt haben, läuft ALG in $O(s\cdot n)$. Der Beweis ist allerdings sehr langwierig und kompliziert, sodass wir hier darauf verzichten, ihn explizit aufzuführen. Insgesamt erhalten wir für das Erstellen der WSPD eine Gesamtlaufzeit von $O(n\log n + s\cdot n).$
    \subsection{Algorithmus für das MVPS}
    \label{subsec:mvps}
    \textellipsis
    Zur Erinnerung: Die Mengen $A_i$ und $B_i$ enthalten die Elemente $x_k = \delta(p_1, p_k)$.
    Als nächstes konstruieren wir aus der WSPD einen gerichteten Graphen $H$. Dabei sind die Knoten von H genau die $2m$ Mengen $A_i$ und $B_i$ und die Kanten sind wie folgt definiert:
    \begin{enumerate}
    	\item Für alle $1 \leq i \leq m$ ist $(A_i, B_i)$ genau dann eine Kante, wenn $(A_i, B_i)$ $(t, \epsilon)$-distanzerhaltend ist und $x_n \in B_i$
    	\item Für alle $1\leq i < j \leq m$ ist $(A_i, A_j)$ genau dann eine Kannte, wenn $(A_i, B_i)$ $t$-distanzerhaltend ist und $A_j \cap B_i \neq \emptyset$
    \end{enumerate}

	\begin{theorem}
		Jede $t$-distanzerhaltende Approximation $Q = (q_1, q_2, \mathellipsis, q_k)$ von $P$ entspricht einem Pfad der Länge $k$ in H von einer Menge $A_i$, die $x_1$ enthält, zu einer Menge $B_j$, die $x_n$ enthält
	\end{theorem}
    
    \subsection{Algorithmus für das MDPS}
    \label{subsec:mdps}
    Heuristischer Algorithmus aus Paper mit allen Erklärungen

    \section{Fazit}
    \label{sec:fazit}

    \bibliography{main}
    \bibliographystyle{plain}

\end{document}
